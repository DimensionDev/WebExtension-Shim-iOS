{"version":3,"sources":["utils/type-transform/BackupFile.ts","extension/background-script/PeopleService.ts"],"names":["UpgradeBackupJSONFile","json","identity","obj","data","version","Array","isArray","whoami","isVersion1","local","key","privateKey","publicKey","isVersion0","localKey","network","userId","async","queryPeople","Object","database","queryMyIdentity","identifier","atSite","database_people","filter","x","Promise","all","map","result","restoreBackup","whoAmI","importKey","crypto","subtle","name","namedCurve","mapID","type","mapGroup","groupId","rec","IAm","previousIdentifiers","person","aes","length","storeMyIdentity","groups","nickname","people","id","prevIds","resolveIdentityAtFacebook","unknown","self","ids","equals","assign","locals","$unknown","$self","updatePersonInfo","avatarURL","__webpack_require__","d","__webpack_exports__","people_gun","Context"],"mappings":"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","file":"js/4.chunk.js","sourcesContent":["export function UpgradeBackupJSONFile(json, identity) {\n    if (isVersion1(json))\n        return json;\n    if (isVersion0(json) && identity) {\n        return {\n            version: 1,\n            whoami: [\n                {\n                    localKey: json.local,\n                    network: 'facebook.com',\n                    publicKey: json.key.key.publicKey,\n                    privateKey: json.key.key.privateKey,\n                    userId: identity.userId || '$self',\n                },\n            ],\n        };\n    }\n    return null;\n}\nfunction isVersion1(obj) {\n    const data = obj;\n    if (data.version !== 1)\n        return false;\n    if (!Array.isArray(data.whoami))\n        return false;\n    if (!data.whoami)\n        return false;\n    return true;\n}\n// tslint:disable-next-line: deprecation\nfunction isVersion0(obj) {\n    // tslint:disable-next-line: deprecation\n    const data = obj;\n    if (!data.local || !data.key || !data.key.key || !data.key.key.privateKey || !data.key.key.publicKey)\n        return false;\n    return true;\n}\n","import { OnlyRunInContext } from '@holoflows/kit/es';\nimport { queryPeopleWithQuery, personRecordToPerson, storeAvatar } from '../../database';\nimport { storeMyIdentityDB, storeLocalKeyDB, storeNewPersonDB, queryMyIdentityAtDB, getMyIdentitiesDB, removeMyIdentityAtDB, queryLocalKeyDB, deleteLocalKeyDB, updatePersonDB, } from '../../database/people';\nimport { UpgradeBackupJSONFile } from '../../utils/type-transform/BackupFile';\nimport { PersonIdentifier, GroupIdentifier } from '../../database/type';\nOnlyRunInContext('background', 'FriendService');\nexport { storeAvatar, getAvatarDataURL as getAvatarBlobURL, queryPerson } from '../../database';\nexport { uploadProvePostUrl } from '../../key-management/people-gun';\n/**\n * Query all people stored\n */\nexport async function queryPeople(network) {\n    return queryPeopleWithQuery({ network });\n}\nexport async function queryMyIdentity(identifier) {\n    if (typeof identifier === 'string') {\n        const all = await getMyIdentitiesDB();\n        const atSite = all.filter(x => x.identifier.network === identifier);\n        return Promise.all(atSite.map(personRecordToPerson));\n    }\n    else {\n        const result = await queryMyIdentityAtDB(identifier);\n        if (result)\n            return [await personRecordToPerson(result)];\n        return [];\n    }\n}\n/**\n * Restore the backup\n */\nexport async function restoreBackup(json, whoAmI) {\n    async function storeMyIdentity(person, local) {\n        await storeMyIdentityDB(person);\n        const aes = await crypto.subtle.importKey('jwk', local, { name: 'AES-GCM', length: 256 }, true, [\n            'encrypt',\n            'decrypt',\n        ]);\n        await storeLocalKeyDB(new PersonIdentifier('facebook.com', '$self'), aes);\n        await storeLocalKeyDB(person.identifier, aes);\n    }\n    function importKey(x) {\n        return crypto.subtle.importKey('jwk', x, { name: 'ECDH', namedCurve: 'K-256' }, true, ['deriveKey']);\n    }\n    function mapID(x) {\n        return new PersonIdentifier(x.network, x.userId);\n    }\n    function mapGroup(x) {\n        return new GroupIdentifier(x.network, x.groupId, x.type);\n    }\n    const data = UpgradeBackupJSONFile(json, whoAmI);\n    if (!data)\n        return false;\n    const whoami = Promise.all(data.whoami.map(async (rec) => {\n        const IAm = mapID(rec);\n        const previousIdentifiers = (rec.previousIdentifiers || []).map(mapID);\n        await storeMyIdentity({\n            identifier: IAm,\n            groups: [],\n            nickname: rec.nickname,\n            previousIdentifiers: previousIdentifiers,\n            publicKey: await importKey(rec.publicKey),\n            privateKey: await importKey(rec.privateKey),\n        }, rec.localKey);\n    }));\n    const people = Promise.all((data.people || []).map(async (rec) => {\n        const id = new PersonIdentifier(rec.network, rec.userId);\n        const groups = (rec.groups || []).map(mapGroup);\n        const prevIds = (rec.previousIdentifiers || []).map(mapID);\n        await storeNewPersonDB({\n            identifier: id,\n            groups: groups,\n            nickname: rec.nickname,\n            previousIdentifiers: prevIds,\n            publicKey: await importKey(rec.publicKey),\n        });\n    }));\n    await whoami;\n    await people;\n    return true;\n}\n/**\n * Resolve my possible identity at facebook.com\n */\nexport async function resolveIdentityAtFacebook(identifier) {\n    const unknown = new PersonIdentifier('facebook.com', '$unknown');\n    const self = new PersonIdentifier('facebook.com', '$self');\n    {\n        const ids = (await getMyIdentitiesDB()).filter(x => x.identifier.equals(unknown) || x.identifier.equals(self));\n        for (const id of ids) {\n            await storeMyIdentityDB(Object.assign({}, id, { identifier }));\n        }\n        removeMyIdentityAtDB(unknown);\n        removeMyIdentityAtDB(self);\n    }\n    {\n        const locals = await queryLocalKeyDB('facebook.com');\n        if (locals) {\n            if (locals.$unknown) {\n                await storeLocalKeyDB(identifier, locals.$unknown);\n            }\n            if (locals.$self) {\n                await storeLocalKeyDB(identifier, locals.$self);\n            }\n            deleteLocalKeyDB(unknown);\n            deleteLocalKeyDB(self);\n        }\n    }\n}\nexport async function updatePersonInfo(identifier, data) {\n    const { avatarURL, nickname } = data;\n    if (nickname)\n        updatePersonDB({ identifier, nickname });\n    if (avatarURL)\n        storeAvatar(identifier, avatarURL);\n}\n"],"sourceRoot":""}